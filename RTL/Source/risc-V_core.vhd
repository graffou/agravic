-- vhdl file of block risc-V_core generated by Agravic
library ieee;use ieee.std_logic_1164.all;use IEEE.NUMERIC_STD.ALL;
library work; use work.structures.all;
entity risc_V_core is port( clk : IN std_logic; reset_n : IN std_logic; load_port_i : IN blk2mem_t; core2instmem_o : OUT blk2mem_t; instmem2core_i : IN mem2blk_t; core2datamem_o : OUT blk2mem_t; datamem2core_i : IN mem2blk_t ); end risc_V_core; architecture rtl of risc_V_core is component dummy_zkw_pouet is port(clk : in std_logic);end component;
       
constant no_type : unsigned ((3 -1) downto 0) := "000";
constant R_type : unsigned ((3 -1) downto 0) := "001";
constant I_type : unsigned ((3 -1) downto 0) := "010";
constant S_type : unsigned ((3 -1) downto 0) := "011";
constant B_type : unsigned ((3 -1) downto 0) := "100";
constant U_type : unsigned ((3 -1) downto 0) := "101";
constant J_type : unsigned ((3 -1) downto 0) := "110";
constant LUI : unsigned ((7 -1) downto 0) := "0110111";
constant AUIPC : unsigned ((7 -1) downto 0) := "0010111";
constant JAL : unsigned ((7 -1) downto 0) := "1101111";
constant JALR : unsigned ((7 -1) downto 0) := "1100111";
constant BRANCH : unsigned ((7 -1) downto 0) := "1100011";
constant LOAD : unsigned ((7 -1) downto 0) := "0000011";
constant STORE : unsigned ((7 -1) downto 0) := "0100011";
constant OPI : unsigned ((7 -1) downto 0) := "0010011";
constant OP : unsigned ((7 -1) downto 0) := "0110011";
constant BEQ : unsigned ((3 -1) downto 0) := "000";
constant BNE : unsigned ((3 -1) downto 0) := "001";
constant BLT : unsigned ((3 -1) downto 0) := "100";
constant BGE : unsigned ((3 -1) downto 0) := "101";
constant BLTU : unsigned ((3 -1) downto 0) := "110";
constant BGEU : unsigned ((3 -1) downto 0) := "111";
constant LB : unsigned ((3 -1) downto 0) := "000";
constant LH : unsigned ((3 -1) downto 0) := "001";
constant LW : unsigned ((3 -1) downto 0) := "010";
constant LBU : unsigned ((3 -1) downto 0) := "100";
constant LHU : unsigned ((3 -1) downto 0) := "101";
constant SB : unsigned ((3 -1) downto 0) := "000";
constant SH : unsigned ((3 -1) downto 0) := "001";
constant SW : unsigned ((3 -1) downto 0) := "010";
constant ADDI : unsigned ((3 -1) downto 0) := "000";
constant SLTI : unsigned ((3 -1) downto 0) := "010";
constant SLTIU : unsigned ((3 -1) downto 0) := "011";
constant XORI : unsigned ((3 -1) downto 0) := "100";
constant ORI : unsigned ((3 -1) downto 0) := "110";
constant ANDI : unsigned ((3 -1) downto 0) := "111";
constant SLLI : unsigned ((3 -1) downto 0) := "001";
constant SRLI : unsigned ((3 -1) downto 0) := "101";
constant SLAI : unsigned ((3 -1) downto 0) := "101";
constant ADDx : unsigned ((3 -1) downto 0) := "000";
constant SUBx : unsigned ((3 -1) downto 0) := "000";
constant SLLx : unsigned ((3 -1) downto 0) := "001";
constant SLTx : unsigned ((3 -1) downto 0) := "010";
constant SLTU : unsigned ((3 -1) downto 0) := "011";
constant XORx : unsigned ((3 -1) downto 0) := "100";
constant SRLx : unsigned ((3 -1) downto 0) := "101";
constant SRAx : unsigned ((3 -1) downto 0) := "101";
constant ORx : unsigned ((3 -1) downto 0) := "110";
constant ANDx : unsigned ((3 -1) downto 0) := "111";
type reg_file_t is array(0 to (32 -1)) of unsigned ((32 -1) downto 0);
signal regs : reg_file_t;
signal PC : unsigned ((32 -1) downto 0);
signal PCp : unsigned ((32 -1) downto 0);
signal loading : std_logic;
signal alt_op : std_logic;
signal cpu_wait : std_logic;
signal flush : std_logic;
signal rimmediate : unsigned ((32 -1) downto 0);
signal use_immediate : std_logic;
signal ropcode : unsigned ((7 -1) downto 0);
signal rfunct3 : unsigned ((3 -1) downto 0);
signal rrd : unsigned ((5 -1) downto 0);
signal rrs1 : unsigned ((5 -1) downto 0);
signal rrs2 : unsigned ((5 -1) downto 0);
signal pipe : unsigned ((4 -1) downto 0);
signal rwb : unsigned ((5 -1) downto 0);
signal funct3wb : unsigned ((3 -1) downto 0);
signal rshiftwb : unsigned ((2 -1) downto 0);
begin
process0 : process(clk,reset_n)
variable instr : unsigned ((32 -1) downto 0);
variable opcode : unsigned ((7 -1) downto 0);
variable rd : unsigned ((5 -1) downto 0);
variable wrd : unsigned ((5 -1) downto 0);
variable rs1 : unsigned ((5 -1) downto 0);
variable rs2 : unsigned ((5 -1) downto 0);
variable funct3 : unsigned ((3 -1) downto 0);
variable funct7 : unsigned ((7 -1) downto 0);
variable immediate : unsigned ((32 -1) downto 0);
variable immediate_type : unsigned ((3 -1) downto 0);
variable op1 : unsigned ((32 -1) downto 0);
variable op2 : unsigned ((32 -1) downto 0);
variable add_res : unsigned ((33 -1) downto 0);
variable sub_res : unsigned ((33 -1) downto 0);
variable sll_res : unsigned ((32 -1) downto 0);
variable srl_res_u : unsigned ((32 -1) downto 0);
variable srl_res_s : unsigned ((32 -1) downto 0);
variable rs1_lt_rs2_u : unsigned ((1 -1) downto 0);
variable rs1_lt_rs2_s : unsigned ((1 -1) downto 0);
variable rs1_eq_rs2 : unsigned ((1 -1) downto 0);
variable and_res : unsigned ((32 -1) downto 0);
variable or_res : unsigned ((32 -1) downto 0);
variable xor_res : unsigned ((32 -1) downto 0);
variable ld_data : unsigned ((32 -1) downto 0);
variable nshift : unsigned ((2 -1) downto 0);
variable wbe : unsigned ((4 -1) downto 0);
variable taken : unsigned ((1 -1) downto 0);
variable rd_val : unsigned ((32 -1) downto 0);
begin
 IF ( reset_n = '0' ) then
  pipe <= TO_UNSIGNED(0,pipe'length);
  PC <= TO_UNSIGNED(0,PC'length);
  PCp <= TO_UNSIGNED(0,PCp'length);
  cpu_wait <= '0';
  flush <= '0';
  alt_op <= '0';
  use_immediate <= '0';
 elsif ( clk'event and (clk = '1' ) ) then
   flush <= '0';
   instr := instmem2core_i.data;
   IF ( cpu_wait = '0' ) then
     pipe <= ( (pipe(pipe'high-1 downto 0)) & '1' );
    PCp <= PC;
    PC <= PC + TO_UNSIGNED(4,PC'length);
   end if;
   IF ( (pipe(0) = '1' ) and (cpu_wait = '0') and (flush = '0') ) then
     opcode := (instr(6 downto 0));
     rd := (instr(11 downto 7));
     rs1 := (instr(19 downto 15));
     rs2 := (instr(24 downto 20));
     funct3 := (instr(14 downto 12));
     funct7 := (instr(31 downto 25));
     IF (opcode = OPI) then
      ropcode <= OP;
     else
      ropcode <= opcode;
     end if;
     rfunct3 <= funct3;
     alt_op <= instr(30);
     rrd <= rd;
     rrs1 <= rs1;
     rrs2 <= rs2;
     case opcode is
      when OPI => immediate_type := I_type;
      when LOAD => immediate_type := I_type;
      when STORE => immediate_type := S_type;
      when LUI => immediate_type := U_type;
      when AUIPC => immediate_type := U_type;
      when JAL => immediate_type := J_type;
      when JALR => immediate_type := J_type;
      when BRANCH => immediate_type := B_type;
      when others => immediate_type := no_type;
     end case;
     case immediate_type is
      when I_type => immediate := unsigned(RESIZE(signed((instr(31 downto 20))), immediate'length));
      when S_type => immediate := unsigned(RESIZE(signed(std_logic_vector(instr(31 downto 20)) & std_logic_vector(instr(11 downto 7))), immediate'length));
      when B_type => immediate := unsigned(RESIZE(signed(std_logic_vector(instr(31 downto 31)) & std_logic_vector(instr(7 downto 7)) & std_logic_vector(instr(30 downto 25)) & std_logic_vector(instr(11 downto 8)) & '0'), immediate'length));
      when U_type => immediate := unsigned(RESIZE(signed(std_logic_vector(instr(31 downto 20)) & std_logic_vector(instr(19 downto 12)) & "000000000000"), immediate'length));
      when J_type => immediate := unsigned(RESIZE(signed(std_logic_vector(instr(31 downto 31)) & std_logic_vector(instr(19 downto 12)) & std_logic_vector(instr(20 downto 20)) & std_logic_vector(instr(30 downto 21)) & "0"), immediate'length));
      when others => immediate := TO_UNSIGNED(0,immediate'length);
     end case;
     IF (opcode = LOAD) then
     end if;
     IF ( (immediate_type = J_type) or (opcode = AUIPC) ) then
      rimmediate <= immediate + PCp;
     else
      rimmediate <= immediate;
     end if;
     IF (immediate_type = no_type) then
      use_immediate <= '1' ;
     else
      use_immediate <= '0';
     end if;
   end if;
   IF ( (pipe(1) = '1' ) and (cpu_wait = '0') and (flush = '0') ) then
    op1 := regs(TO_INTEGER(rrs1));
    IF ( use_immediate = '1' ) then
      op2 := rimmediate;
    else
     op2 := regs(TO_INTEGER(rrs2));
    end if;
    add_res := RESIZE(op1, add_res'length) + RESIZE(op2, add_res'length);
    sub_res := RESIZE(op1, add_res'length) - RESIZE(op2, add_res'length);
    rs1_lt_rs2_u := RESIZE((sub_res(32 downto 32)),1);
    rs1_lt_rs2_s := RESIZE((sub_res(32 downto 32)) xor (op1(31 downto 31)) xor (op2(31 downto 31)),1);
    IF (sub_res = TO_UNSIGNED(0,sub_res'length)) then
      rs1_eq_rs2 := "1";
    else
      rs1_eq_rs2 := "0";
    end if;
    sll_res := SHIFT_LEFT(op1, TO_INTEGER(RESIZE(op2, 5)));
    srl_res_u := SHIFT_RIGHT(op1, TO_INTEGER(RESIZE(op2, 5)));
    srl_res_s := unsigned(SHIFT_RIGHT(signed(op1), TO_INTEGER(RESIZE(op2, 5))));
    and_res := op1 and op2;
    or_res := op1 or op2;
    xor_res := op1 xor op2;
    nshift := RESIZE(add_res, nshift'length);
    case ropcode is
     when OP =>
      case rfunct3 is
       when ADDx => IF (alt_op = '0') then rd_val := RESIZE(add_res, regs(0)'length); else rd_val := RESIZE(sub_res, regs(0)'length); end if;
       when SLLx => rd_val := sll_res;
       when SRLx => IF (alt_op = '0') then rd_val := srl_res_u; else rd_val := srl_res_s; end if;
       when SLTx => IF (alt_op = '1' ) then rd_val := RESIZE(rs1_lt_rs2_s, regs(0)'length); else rd_val := RESIZE(rs1_lt_rs2_u, regs(0)'length); end if;
       when ORx => rd_val := or_res;
       when XORx => rd_val := xor_res;
       when ANDx => rd_val := and_res;
       when others => rd_val := and_res;
      end case;
     when LOAD =>
      cpu_wait <= '1' ;
      rwb <= rrd;
      funct3wb <= rfunct3;
      rshiftwb <= nshift;
      core2datamem_o.addr <= (PC(core2datamem_o.addr'length+1 downto 2));
      core2datamem_o.cs_n <= '0';
      core2datamem_o.wr_n <= '1' ;
      core2datamem_o.be <= "1111";
     when STORE =>
      core2datamem_o.addr <= (PC(core2datamem_o.addr'length+1 downto 2));
      core2datamem_o.cs_n <= '0';
      core2datamem_o.wr_n <= '0';
      wbe := ( rfunct3(1) & rfunct3(1) & rfunct3(0) & '1' );
      wbe := SHIFT_LEFT(wbe, TO_INTEGER(nshift));
      core2datamem_o.be <= wbe;
      core2datamem_o.data <= SHIFT_LEFT(regs(TO_INTEGER(rrs2)), TO_INTEGER(nshift & "000"));
     when LUI => rd_val := rimmediate;
     when AUIPC => rd_val := rimmediate;
     when JAL => PC <= rimmediate; rd_val := PC; cpu_wait <= '1' ;
     when JALR => PC <= RESIZE(add_res, PC'length); rd_val := PC; cpu_wait <= '1' ;
     when BRANCH =>
      taken := ( (rfunct3(1 downto 1)) and (rs1_lt_rs2_u xor (rfunct3(0 downto 0))) ) and
         ( ((rfunct3(1 downto 1)) xor (rfunct3(2 downto 2)) ) and (rs1_lt_rs2_u xor (rfunct3(0 downto 0))) ) and
         ( not ((rfunct3(1 downto 1)) and not (rfunct3(2 downto 2)) ) and (rs1_eq_rs2 xor (rfunct3(0 downto 0))) );
      IF (taken = "1") then
       PC <= rimmediate; cpu_wait <= '1' ;
      end if;
     when others => rd_val := and_res;
    end case;
    IF ( not (ropcode = LOAD) and not (ropcode = STORE) ) then
     core2datamem_o.cs_n <= '1' ;
    end if;
    wrd := rrd;
   end if;
   IF ( not(rwb = TO_UNSIGNED(0,rwb'length)) and (datamem2core_i.data_en = '1' ) ) then
    cpu_wait <= '0';
    ld_data := datamem2core_i.data;
    ld_data := SHIFT_RIGHT(ld_data, TO_INTEGER( (rshiftwb & "000")));
    case funct3wb is
     when LW => rd_val := ld_data;
     when LH => rd_val := unsigned(RESIZE(signed((ld_data(15 downto 0))), rd_val'length));
     when LHU => rd_val := RESIZE((ld_data(15 downto 0)), rd_val'length);
     when LB => rd_val := unsigned(RESIZE(signed((ld_data(7 downto 0))), rd_val'length));
     when LBU => rd_val := RESIZE((ld_data(7 downto 0)), rd_val'length);
     when others => rd_val := TO_UNSIGNED(0,rd_val'length);
    end case;
    wrd := rwb;
   end if;
   regs(TO_INTEGER(wrd)) <= rd_val;
   regs(0) <= TO_UNSIGNED(0,regs(0)'length);
   IF (load_port_i.wr_n = '0' ) then
    loading <= '1' ;
    PC <= RESIZE( load_port_i.addr, PC'length );
    PCp <= load_port_i.data;
   elsif ( loading = '1' ) then
    PC <= TO_UNSIGNED(0,PC'length);
    loading <= '0';
   end if;
 end if;
 end process;

  core2instmem_o.addr <= (PC(core2instmem_o.addr'length+1 downto 2));
  core2instmem_o.data <= PCp;
  core2instmem_o.cs_n <= '0';
  core2instmem_o.wr_n <= not loading;
  core2instmem_o.be <= "1111";

end rtl;
