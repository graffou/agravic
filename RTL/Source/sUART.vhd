-- vhdl file of block sUART generated by Agravic
library ieee;use ieee.std_logic_1164.all;use IEEE.NUMERIC_STD.ALL;
library work; use work.structures.all;
library work; use work.altera.all;



entity sUART is generic (generic_int: integer); port ( clk_peri : IN std_logic; reset_n : IN std_logic; boot_mode_i : IN std_logic; core2mem_i : IN blk2mem_t; mem2core_o : OUT mem2blk_t; irq_o : OUT std_logic; uart_dma_i : IN d2p_8_t; uart_dma_o : OUT p2d_8_t; uart_tx_o : OUT std_logic; uart_rx_i : IN std_logic ); end sUART; architecture rtl of sUART is component dummy_zkw_pouet is port(clk : in std_logic);end component;
signal div : unsigned ((16 -1) downto 0);
signal cnt : unsigned ((16 -1) downto 0);
signal conf : unsigned ((32 -1) downto 0);
signal byte : unsigned ((8 -1) downto 0);
signal byte0 : unsigned ((8 -1) downto 0);
signal send_tx_byte : std_logic;
signal get_rx_byte : std_logic;
signal uart_rx : std_logic;
signal rx_started : std_logic;
signal ready : std_logic;
signal boot_mode : std_logic;
signal state : unsigned ((5 -1) downto 0);

constant reg_base_addr : unsigned ((core2mem_i.addr'length-1) downto 0) := TO_UNSIGNED(generic_int,core2mem_i.addr'length);
signal base_addr_test : unsigned ((core2mem_i.addr'length-1) downto 0);
constant reg_addr_lsbs : INTEGER := ( generic_int / 268435456);
signal addr_lsbs_test : unsigned ((4 -1) downto 0);

signal base_addr_ok : std_logic;
signal addr_ok : std_logic;

begin






process0 : process(clk_peri,reset_n)

variable rx_trans : std_logic;
variable val : unsigned ((32 -1) downto 0);
variable reset_data_en : std_logic;
variable DBG : unsigned ((8 -1) downto 0);

begin
 IF ( reset_n = '0' ) then
  cnt <= TO_UNSIGNED(0,cnt'length);
  boot_mode <= '0';





  div <= TO_UNSIGNED((417),div'length);

  ready <= '1' ;
  uart_tx_o <= '1' ;

  state <= TO_UNSIGNED(24,state'length);
  byte <= TO_UNSIGNED(0,byte'length);
  uart_rx <= '1' ;
  rx_started <= '0';
  get_rx_byte <= '1' ;
  send_tx_byte <= '0';
  base_addr_test <= reg_base_addr;
  addr_lsbs_test <= TO_UNSIGNED(reg_addr_lsbs,4);
  irq_o <= '0';

 elsif ( clk_peri'event and (clk_peri = '1' ) ) then
  cnt <= cnt - TO_UNSIGNED(1,cnt'length);
  reset_data_en := '0';
  boot_mode <= boot_mode_i;
  IF ( (boot_mode = '0') and (boot_mode_i = '1' )) then
   reset_data_en := '1' ;
  end if;

  mem2core_o.data_en <= '0';
  mem2core_o.data <= TO_UNSIGNED(0,32);

  IF ( ( core2mem_i.cs_n = '0' ) and ( (core2mem_i.addr(core2mem_i.addr'high downto ( (generic_int / 268435456 + 16) rem 16 ))) = (reg_base_addr(reg_base_addr'high downto ( (generic_int / 268435456 + 16) rem 16 ))) ) ) then
   base_addr_ok <= '1' ;

   IF (core2mem_i.wr_n = '0' ) then

    IF ((core2mem_i.addr(( (generic_int / 268435456 + 16) rem 16 )-1 downto 0)) = TO_UNSIGNED(0,( (generic_int / 268435456 + 16) rem 16 ))) then
     addr_ok <= '1' ;
     val := core2mem_i.data;
     div <= (val(31 downto 16));
     byte <= (val(7 downto 0));
     get_rx_byte <= val(8);
     send_tx_byte <= not val(8);
     cnt <= TO_UNSIGNED(0,cnt'length);
     state <= TO_UNSIGNED(24,state'length);
     rx_started <= '0';
     ready <= '0';
     reset_data_en := '1' ;
    end if;
   else


    IF ((core2mem_i.addr(( (generic_int / 268435456 + 16) rem 16 )-1 downto 0)) = TO_UNSIGNED(0,( (generic_int / 268435456 + 16) rem 16 ))) then
     mem2core_o.data_en <= '1' ;
     mem2core_o.data <= ( div & TO_UNSIGNED(0,7) & ready & byte );
    end if;
   end if;
  end if;
  IF ( uart_dma_i.data_en = '1' ) then
   send_tx_byte <= '1' ;
   get_rx_byte <= '0';
   byte <= uart_dma_i.data;
   cnt <= TO_UNSIGNED(0,cnt'length);
   ready <= '0';
   uart_dma_o.rdy <= '0';
  end if;

  irq_o <= '0';

  IF ( (send_tx_byte = '1' ) and (cnt = TO_UNSIGNED(0,cnt'length)) ) then
   case (state) is
    when "11000" => uart_tx_o <= '0'; cnt <= div; state <= "00000";
    when "01000" => uart_tx_o <= '1' ; cnt <= div; state <= "10000";
    when "10000" => uart_tx_o <= '1' ; state <= "11000"; send_tx_byte <= '0'; get_rx_byte <= '1' ; ready <= '1' ;uart_dma_o.rdy <= '1' ; irq_o <= '1' ;
    when others => cnt <= div; uart_tx_o <= byte(0); state <= state + TO_UNSIGNED(1,state'length); byte <= SHIFT_RIGHT(byte, 1);
   end case;
  end if;


  IF ( (get_rx_byte = '1' ) ) then
   rx_trans := ( uart_rx and not uart_rx_i );
   if ( (uart_dma_i.grant = '1' ) or (reset_data_en = '1' ) ) then
    uart_dma_o.data_en <= '0';
   end if;

   uart_rx <= uart_rx_i;
   if ( rx_trans = '1' ) then
    cnt <= SHIFT_RIGHT(div, 1);
    rx_started <= '1' ;
   end if;

   IF ( (rx_started = '1' ) and (cnt = TO_UNSIGNED(0,cnt'length)) ) then
    case (state) is
     when "11000" => cnt <= div; state <= "00000";
     when "01000" => cnt <= TO_UNSIGNED(0,cnt'length); state <= "10000";
     when "10000" => state <= "11000"; ready <= '1' ; uart_dma_o.data <= byte; uart_dma_o.data_en <= '1' ; rx_started <= '0'; irq_o <= '1' ;
     when others => cnt <= div; byte <= (SHIFT_RIGHT(byte, 1) or (uart_rx & "0000000")); state <= state + TO_UNSIGNED(1,state'length);
    end case;
   end if;

  end if;

 end if;
end process;

end rtl;
