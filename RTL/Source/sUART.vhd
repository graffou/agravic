-- vhdl file of block sUART generated by Agravic
library ieee;use ieee.std_logic_1164.all;use IEEE.NUMERIC_STD.ALL;
library work; use work.structures.all;
library work; use work.altera.all;
entity sUART is port( clk_peri : IN std_logic; reset_n : IN std_logic; core2mem_i : IN blk2mem_t; mem2core_o : OUT mem2blk_t; uart_tx_o : OUT std_logic; uart_rx_i : IN std_logic ); end sUART; architecture rtl of sUART is component dummy_zkw_pouet is port(clk : in std_logic);end component;
signal div : unsigned ((16 -1) downto 0);
signal cnt : unsigned ((16 -1) downto 0);
signal conf : unsigned ((32 -1) downto 0);
signal byte : unsigned ((8 -1) downto 0);
signal send_tx_byte : std_logic;
signal get_rx_byte : std_logic;
signal uart_rx : std_logic;
signal rx_started : std_logic;
signal ready : std_logic;
signal state : unsigned ((5 -1) downto 0);
begin
process0 : process(clk_peri,reset_n)
variable DBG : unsigned ((8 -1) downto 0);
variable rx_trans : std_logic;
variable val : unsigned ((32 -1) downto 0);
begin
 IF ( reset_n = '0' ) then
  cnt <= TO_UNSIGNED(0,cnt'length);
  div <= TO_UNSIGNED((434),div'length);
  ready <= '1' ;
  uart_tx_o <= '1' ;
  state <= "00000";
  byte <= TO_UNSIGNED(0,byte'length);
  uart_rx <= '1' ;
  rx_started <= '0';
  get_rx_byte <= '0';
  send_tx_byte <= '0';
 elsif ( clk_peri'event and (clk_peri = '1' ) ) then
  cnt <= cnt - TO_UNSIGNED(1,cnt'length);
  mem2core_o.data_en <= '0';
  mem2core_o.data <= TO_UNSIGNED(0,32);
  IF ( ( core2mem_i.cs_n = '0' ) and ( (core2mem_i.addr(12 downto 4)) = "111111111" ) ) then
   IF (core2mem_i.wr_n = '0' ) then
    IF (core2mem_i.addr = "1111111110000") then
     val := core2mem_i.data;
     div <= (val(31 downto 16));
     byte <= (val(7 downto 0));
     get_rx_byte <= val(8);
     send_tx_byte <= not val(8);
     cnt <= TO_UNSIGNED(0,cnt'length);
     state <= TO_UNSIGNED(24,state'length);
     rx_started <= '0';
     ready <= '0';
    end if;
   else
    IF (core2mem_i.addr = "1111111110000") then
     mem2core_o.data_en <= '1' ;
     mem2core_o.data <= ( div & TO_UNSIGNED(0,7) & ready & byte );
    end if;
   end if;
  end if;
  IF ( (send_tx_byte = '1' ) and (cnt = TO_UNSIGNED(0,cnt'length)) ) then
   case (state) is
    when "11000" => uart_tx_o <= '0'; cnt <= div; state <= "00000";
    when "01000" => uart_tx_o <= '1' ; cnt <= div; state <= "10000";
    when "10000" => uart_tx_o <= '1' ; state <= "11000"; send_tx_byte <= '0'; ready <= '1' ;
    when others => cnt <= div; uart_tx_o <= byte(0); state <= state + TO_UNSIGNED(1,state'length); byte <= SHIFT_RIGHT(byte, 1);
   end case;
  end if;
  IF ( (get_rx_byte = '1' ) ) then
   rx_trans := ( uart_rx and not uart_rx_i );
   uart_rx <= uart_rx_i;
   if ( rx_trans = '1' ) then
    cnt <= SHIFT_RIGHT(div, 1);
    rx_started <= '1' ;
   end if;
   IF ( (rx_started = '1' ) and (cnt = TO_UNSIGNED(0,cnt'length)) ) then
    case (state) is
     when "11000" => cnt <= div; state <= "00000";
     when "01000" => cnt <= div; state <= "10000";
     when "10000" => state <= "11000"; ready <= '1' ;
     when others => cnt <= div; byte <= (SHIFT_RIGHT(byte, 1) or (uart_rx & "0000000")); state <= state + TO_UNSIGNED(1,state'length);
    end case;
   end if;
  end if;
 end if;
end process;
end rtl;
