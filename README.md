# agravic 
## What is Agravic ?
Agravic is a framework that enables writing VHDL-like code inside a C++ program.
It uses heavy preprocessor abuse for that, but the counterpart is that synthesizable VHDL code can be preprocessor-generated from the C++ code!

The syntax has been chosen to enable VHDL and C++ code generation using the C preprocessor and sed. At first, it might seem confusing for both C++ developers and rtl designers, but in the end, the syntax is so close to VHDL's that I feel this is not a problem.

**So, agravic enables rtl code writing without the expense of EDA tools.**
Furthermore, C++ simulation of agravic designs should be faster than classical rtl simulation. 

### Limitations
* Unlike mentor ac_int types, arbitrary length types in Agravic only cover the 1-64 bits range. This is generally enough for most designs.
* True combinational logic does not exist in Agravic. Traditional uses of combinational logic can be achieved this way:
    - Use in-process variables for intermediate calculations
    - Use clock-driven combinational processes for output assignments
    - The risc-V SoC example shows how to do this
* For now, a single clock signal is supported. Though, gated clocks can be created, but only inside the hierarchy level where the main clock is created.

## Requirements
* A linux distribution, with a recent gcc ( > 7.4 ).
* Ubuntu on windows, cygwin might do the job as well.
* Gtkwave is highly recommended for waveform viewing.

## Provided example (small risc-V SoC based on Giorno core)
A risc-V SoC example is provided to demonstrate the platform capabilities, for simulation and rtl generation as well.

The SoC is composed of the Giorno risc-V core (custom design based on rv32i instruction set), two 24kB RAMs (instruction and data) and a peripheral block (just 32 GPIOs for now).

**93 verification tests are provided** (the rv32i subset of the risc-V compliance tests), which all pass except of the CSR, FENCE and MISALIGN ones.

Running the non-regression suite is statisfyingly fast: it obviously deserves being run every time you change a single line of the rtl code. 

A very simple bare-metal gcc example C-code can be found in the FIRMWARE directory.

The generated rtl synthesizes in quartus, and should run at 48MHz on an Arduino Vidor board (using 25% of the Cyclone10LP Logic elements).

## Directory organization

* Main.cpp and all rtl blocks (.h files) are found in the Source directory.

* Include_libs contains the Agravic framework.

* Include_rtl contains the C++ compilable versions of the rtl blocks found in Source. These are generated by the Makefile.

* RTL contains the VHDL versions of the rtl blocks found in Source. These are generated by the Makefile. You'll find a (basic) quartus project as well.

* Tests contains the non-regression tests (binaries and references). 

* FIRMWARE contains the c-code and utilities for firmware development. This c example is based on the ibex core bare-metal example.

## Run the risc-V SoC example
### Generate executable and rtl:

    make
### Generate non-regression executable and non-regression executable:
    make nonreg

The non-regression executable differs from the previous one by its ability to abort at the end of the test and check the results (it compares memory content to the reference one, which is expected by the risc-V compliance tests).
### Build the bare-metal C example:
    cd FIRMWARE
    make
    cd ..
### Select internal signals to be probed in dut.vcd:
edit vcd.scn file.

A single signal is probed by invoking its full hierarchy:

    tb:dut:u0_peripherals:gpios_o  
       
Adding bin to signal name probes it in binary format:

    tb:dut:u0_peripherals:gpios_o bin
    
Adding all signals inside a hierarchy level:

    tb:dut:u0_peripherals:  
    
**Once a probe is declared, its format is definitive. It also conditions the format of all connected nets (ports etc.). So, all 'bin' probes must be declared first in vcd.scn.**     
### Run the SoC
    make
    
    ./dut -ncycles 200000 -bin_file 'FIRMWARE/led.bin'   

    gtkwave dut.vcd

Then navigate inside the hierarchy to watch internal signals.
This example toggles the GPIO values every 1ms (see gpios signal in the peripherals block).
### Have a look to printf outputs
gprintf is a simple printf implementation in C++ language.
It outputs text using the gpio output, which is hacked in peripherals.h to produce console output.
It makes use of recursive templates to implement multiple arguments printf, so any gprintf with a new set of argument types has a cost in terms of program memory.
Since argument types does not need to be specified, the formatting argument is used to specify the output color.
Basic print colors are black, blue, magenta, cyan, red, green and yellow, respecting the color code of matlab (k, b, m, c, r, g, and y)
For bold print, color codes must be specified in capital letters (K, B, M etc.)
Some print codes with background color are T, U, V and W. These are an arbitrary choice of FG/BG colors.
The base color of any gprintf is specified at the beginning of the formatting string, beginning with '#':
gprintf("#R Yo! %Y and be %G", "man", "cool");
will print  the text in the formatting string with default color R (bold red) and the aguments ("man" and "cool") in bold yellow color.
For now, only uint32, int32, char and bool arguments are supported.
Check FIRMWARE/led.c for examples.

To see gprintf outputs, just launch:

	tail -f dbg_file !!in a new terminal!!

where the executable is launched.
gprintf outputs show up in the terminal as you launch simulations.

### Run the non-regression tests:
    make nonreg
    ./nonreg
    more test_results
The test_results file only contains the list of failed tests.
### Run any of the non-regression tests (for example xor instruction test):
    ./dut -ncycles 10000 -bin_file 'tests/xor.elf.bin'

